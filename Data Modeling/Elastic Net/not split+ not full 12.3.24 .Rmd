---
title: "elastic net"
output:
  pdf_document: default
  html_document: default
date: "2024-11-20"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# "final_full_rmna_OneHotEncoded_housing.csv" (no outliers removed)
# "final_rmna_OneHotEncoded_housing.csv" (price outliers removed)

```{r}
library(readr)
library(glmnet)

setwd("~/Desktop/625 final project")
housing_data <- read_csv("final_rmna_OneHotEncoded_housing.csv")
set.seed(34)

#other seed option: 55

```

```{r}
attach(housing_data)

#transform price into log_price
housing_data$log_price=log(housing_data$`Price (in rupees)`)
X <- housing_data[, -which(names(housing_data) == "Price (in rupees)" | names(housing_data) == "log_price")] 
Y <- housing_data$log_price
X_matrix <- as.matrix(X)
Y_matrix <- as.matrix(Y)
```

```{r}
# Initialize storage
alphas <- seq(0, 1, by = 0.01)
elastic_net <- list()  # A list to store models
best_lambda <- numeric(length(alphas))  # Numeric vector for best lambda values
predicted_prices <- list()  # A list to store predictions
results <- list()  # A list to store data frames with actual and predicted values
rmse <- numeric(length(alphas))   # Numeric vector for RMSE values
mae <- numeric(length(alphas))   # Numeric vector for MAE values
mape=numeric(length(alphas))  # Numeric vector for MAPE values

for (i in seq_along(alphas)) {
  alpha=alphas[i]
  # Fit elastic net model with alpha = i/20
  elastic_net[[i]] <- cv.glmnet(X_matrix, Y_matrix, alpha = alpha)
  
  # Store the best lambda value (we choose lambda where MSE is smallest) #lambda.min
  best_lambda[i] <- elastic_net[[i]]$lambda.1se
  
  # Predict on the test set using the best lambda
  predicted_prices[[i]] <- predict(elastic_net[[i]], newx = X_matrix, s = "lambda.1se")
  
  # Combine actual and predicted values
  results[[i]] <- data.frame(Actual = Y_matrix, Predicted = as.vector(predicted_prices[[i]]))
  # Compute RMSE, MAE, MAPE
  rmse[i] <- sqrt(mean((results[[i]]$Actual - results[[i]]$Predicted)^2))
  mae[i] <- mean(abs(results[[i]]$Actual - results[[i]]$Predicted))
  mape[i] <- mean(abs((results[[i]]$Actual - results[[i]]$Predicted) / results[[i]]$Actual)) * 100
}
```

```{r}
# Results for RMSE, MAE and MAPE
print(rmse)
which.min(abs(rmse))
```

```{r}
print(mae)
which.min(abs(mae))
```

```{r}
print(mape)
which.min(abs(mape))
```

```{r}
plot(alphas,rmse)
plot(alphas,mape)
plot(alphas, mae)
```
Is alpha = 0 a weird value?

```{r}
fit= cv.glmnet(X_matrix, Y_matrix, alpha = 0.01)
plot(fit)
# two methods to choose lambda
fit$lambda.1se
fit$lambda.min
```

s comes from lambda.1se

```{r}
# Compute RMSE, MAE, MAPE and R_squared in training dataset
predicted_prices<- predict(fit, newx = X_matrix,s=0.03522713)
  
  # Combine actual and predicted values
results<- data.frame(Actual = Y_matrix, Predicted = as.vector(predicted_prices))
  
  rmse<- sqrt(mean((results$Actual - results$Predicted)^2))
  mae<- mean(abs(results$Actual - results$Predicted))
  mape<- mean(abs((results$Actual - results$Predicted) / results$Actual)) * 100
  rmse
  mae
  mape


y_mean <- mean(Y_matrix)
SS_total <- sum((Y_matrix - y_mean)^2)
SS_residual <- sum((Y_matrix - predicted_prices)^2)
R_squared <- 1 - (SS_residual / SS_total)
print(R_squared)

```


